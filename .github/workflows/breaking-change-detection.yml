name: Breaking Change Detection

on:
  pull_request:
    types: [opened, synchronize, edited]

jobs:
  detect-breaking-changes:
    name: Detect Potential Breaking Changes
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze changes for breaking patterns
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || '';

            // Get changed files
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            // Helper function to normalize function signature (remove type annotations)
            function normalizeSignature(line) {
              // Remove leading +/- from diff
              let sig = line.replace(/^[+-]\s*/, '');
              // Remove return type annotations (-> Type:)
              sig = sig.replace(/\s*->\s*[^:]+:/, ':');
              // Remove parameter type annotations (param: Type -> param)
              sig = sig.replace(/(\w+)\s*:\s*[^,)=]+/g, '$1');
              return sig.trim();
            }

            // Helper function to extract function name from signature
            function extractFunctionName(line) {
              const match = line.match(/def\s+(\w+)\s*\(/);
              return match ? match[1] : null;
            }

            // Helper function to check if signature change is only type annotations
            function isOnlyTypeAnnotationChange(removedLine, addedLine) {
              const normalizedRemoved = normalizeSignature(removedLine);
              const normalizedAdded = normalizeSignature(addedLine);
              return normalizedRemoved === normalizedAdded;
            }

            // Patterns that may indicate breaking changes
            const breakingPatterns = [
              {
                pattern: /^-\s*def\s+\w+\(/m,
                description: 'Function signature removed or modified',
                severity: 'high',
                checkTypeAnnotations: true
              },
              {
                pattern: /^-\s*class\s+\w+/m,
                description: 'Class definition removed or modified',
                severity: 'high',
                checkTypeAnnotations: false
              },
              {
                pattern: /^-\s*async\s+def\s+\w+\(/m,
                description: 'Async function removed or modified',
                severity: 'high',
                checkTypeAnnotations: true
              },
              {
                pattern: /^-.*__init__\s*\(/m,
                description: 'Constructor signature changed',
                severity: 'high',
                checkTypeAnnotations: true
              },
              {
                pattern: /^-.*raise\s+\w+Error/m,
                description: 'Exception type changed',
                severity: 'medium',
                checkTypeAnnotations: false
              },
              {
                pattern: /__all__.*=/,
                description: 'Public API exports modified',
                severity: 'high',
                checkTypeAnnotations: false
              },
              {
                pattern: /^-.*@property/m,
                description: 'Property removed or modified',
                severity: 'medium',
                checkTypeAnnotations: false
              }
            ];

            let potentialBreaking = [];
            const pythonFiles = files.data.filter(f =>
              f.filename.match(/\.py$/) &&
              !f.filename.match(/^tests?\//) &&
              !f.filename.match(/test_\w+\.py$/)
            );

            for (const file of pythonFiles) {
              if (!file.patch) continue;

              const matches = [];
              const patchLines = file.patch.split('\n');

              for (const {pattern, description, severity, checkTypeAnnotations} of breakingPatterns) {
                if (!pattern.test(file.patch)) continue;

                // For function signature patterns, check if it's only type annotations
                if (checkTypeAnnotations) {
                  let isBreaking = false;
                  console.log(`\n=== Checking ${description} in ${file.filename} ===`);

                  // Find all removed function signatures
                  for (let i = 0; i < patchLines.length; i++) {
                    const line = patchLines[i];
                    if (!pattern.test(line)) continue;

                    console.log(`Found removed line: ${line}`);
                    const funcName = extractFunctionName(line);
                    console.log(`Extracted function name: ${funcName}`);

                    if (!funcName) {
                      console.log('Failed to extract function name, marking as breaking');
                      isBreaking = true;
                      break;
                    }

                    // Look for corresponding added line with same function name
                    let foundMatch = false;
                    for (let j = 0; j < patchLines.length; j++) {
                      const addedLine = patchLines[j];
                      if (!addedLine.startsWith('+')) continue;

                      const addedFuncName = extractFunctionName(addedLine);
                      if (addedFuncName === funcName) {
                        console.log(`Found potential match: ${addedLine}`);

                        const normRemoved = normalizeSignature(line);
                        const normAdded = normalizeSignature(addedLine);
                        console.log(`Normalized removed: ${normRemoved}`);
                        console.log(`Normalized added: ${normAdded}`);
                        console.log(`Are they equal? ${normRemoved === normAdded}`);

                        // Check if only type annotations changed
                        if (isOnlyTypeAnnotationChange(line, addedLine)) {
                          console.log(`Type annotation only change - NOT breaking`);
                          foundMatch = true;
                          break;
                        } else {
                          console.log(`Signatures differ beyond type annotations`);
                        }
                      }
                    }

                    // If no matching added line, or signatures differ beyond type hints, it's breaking
                    if (!foundMatch) {
                      console.log(`No match found for ${funcName}, marking as breaking`);
                      isBreaking = true;
                      break;
                    } else {
                      console.log(`Match found for ${funcName}, continuing`);
                    }
                  }

                  console.log(`Final decision: isBreaking = ${isBreaking}`);
                  if (isBreaking) {
                    matches.push({description, severity});
                  }
                } else {
                  // For non-function patterns, use simple pattern matching
                  matches.push({description, severity});
                }
              }

              if (matches.length > 0) {
                potentialBreaking.push({
                  file: file.filename,
                  additions: file.additions,
                  deletions: file.deletions,
                  changes: file.changes,
                  issues: matches
                });
              }
            }

            // Check if BREAKING CHANGE is documented
            const hasBreakingChangeDoc = /BREAKING CHANGE:/i.test(body) ||
                                        /breaking change/i.test(body);

            if (potentialBreaking.length > 0) {
              const hasHighSeverity = potentialBreaking.some(item =>
                item.issues.some(issue => issue.severity === 'high')
              );

              // Build detailed report
              let report = '## ‚ö†Ô∏è Potential Breaking Changes Detected\n\n';
              report += 'This PR modifies code that may constitute a breaking change.\n\n';
              report += '### Files with Potential Breaking Changes:\n\n';

              for (const item of potentialBreaking) {
                report += `**${item.file}** (+${item.additions}/-${item.deletions}):\n`;
                for (const issue of item.issues) {
                  const emoji = issue.severity === 'high' ? 'üî¥' : 'üü°';
                  report += `  ${emoji} ${issue.description}\n`;
                }
                report += '\n';
              }

              if (!hasBreakingChangeDoc) {
                report += '### ‚ùå Required Actions\n\n';
                report += 'Breaking changes detected but not documented!\n\n';
                report += '**You must:**\n';
                report += '1. Add `BREAKING CHANGE:` footer to your commit message\n';
                report += '2. Document the breaking change in the PR description\n';
                report += '3. Add migration guide to CHANGELOG.md\n';
                report += '4. Update documentation\n\n';
                report += '**Commit message format:**\n';
                report += '```\n';
                report += 'feat: add new authentication system\n\n';
                report += 'Migrate authentication to use OAuth2 instead of basic auth.\n\n';
                report += 'BREAKING CHANGE: BasicAuth class removed. Use OAuth2Provider instead.\n';
                report += 'See docs/migration.md for migration guide.\n';
                report += '```\n\n';
                report += '**PR description must include:**\n';
                report += '- What changed and why\n';
                report += '- How to migrate existing code\n';
                report += '- Examples of before/after usage\n';
              } else {
                report += '### ‚úÖ Breaking Change Documented\n\n';
                report += 'Good! This PR includes breaking change documentation.\n\n';
                report += '**Before merging, verify:**\n';
                report += '- [ ] Migration guide in CHANGELOG.md\n';
                report += '- [ ] Documentation updated\n';
                report += '- [ ] Examples updated\n';
                report += '- [ ] Version will be bumped appropriately (major version)\n';
              }

              // Create or update comment
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number
              });

              const botComment = comments.data.find(c =>
                c.user.type === 'Bot' &&
                c.body.includes('Potential Breaking Changes Detected')
              );

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: report
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: report
                });
              }

              // Fail if high severity and not documented
              if (hasHighSeverity && !hasBreakingChangeDoc) {
                core.setFailed(
                  '‚ùå Breaking changes detected but not documented!\n' +
                  'Add BREAKING CHANGE: footer to commit message and document in PR description.'
                );
              } else if (!hasBreakingChangeDoc) {
                core.warning(
                  '‚ö†Ô∏è Potential breaking changes detected. Please review and document if needed.'
                );
              } else {
                console.log('‚úÖ Breaking changes properly documented');
              }
            } else {
              console.log('‚úÖ No potential breaking changes detected');
            }
